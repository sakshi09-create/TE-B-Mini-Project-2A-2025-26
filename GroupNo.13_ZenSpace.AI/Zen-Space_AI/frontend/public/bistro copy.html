<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bistro Set Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Orbit Controls for user interaction (mouse drag to rotate) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Inter', sans-serif; }
        #scene-container {
            width: 100vw;
            height: 85vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            touch-action: none;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
        .color-group { margin-bottom: 10px; }
        .color-label { font-size: 0.875rem; font-weight: 600; color: #4b5563; }
    </style>
</head>
<body>

    <div class="p-6 bg-white border-b border-gray-200">
        <h1 class="text-2xl font-bold text-gray-900">Interactive 3D Bistro Set</h1>
        <p id="subtitle" class="text-sm text-gray-500 mt-1">Click and drag to rotate the product.</p>
    </div>

    <!-- UI Control Panel -->
    <div id="controls-panel">
        <h2 class="text-lg font-bold mb-3">Customize</h2>
        
        <div class="color-group">
            <label for="frameColor" class="color-label block mb-1">Frame Color:</label>
            <input type="color" id="frameColor" value="#333333" class="w-full h-8 p-1 rounded-md border border-gray-300">
        </div>

        <div class="color-group">
            <label for="woodColor" class="color-label block mb-1">Wood Color:</label>
            <input type="color" id="woodColor" value="#b8860b" class="w-full h-8 p-1 rounded-md border border-gray-300">
        </div>
    </div>

    <div id="scene-container">
        <!-- The Three.js canvas will be inserted here -->
    </div>

    <script>
        // --- Globals ---
        let scene, camera, renderer, controls, productGroup;
        let container = document.getElementById('scene-container');
        let frameMaterial, woodMaterial;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd); 

            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            renderer.shadowMap.enabled = true;

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040, 1.5));
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
            scene.add(hemisphereLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Materials
            frameMaterial = new THREE.MeshStandardMaterial({ 
                color: parseInt(document.getElementById('frameColor').value.substring(1), 16),
                roughness: 0.6,
                metalness: 0.8
            });
            woodMaterial = new THREE.MeshStandardMaterial({ 
                color: parseInt(document.getElementById('woodColor').value.substring(1), 16),
                roughness: 0.8, 
                metalness: 0.1
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('frameColor').addEventListener('input', (e) => frameMaterial.color.set(e.target.value));
            document.getElementById('woodColor').addEventListener('input', (e) => woodMaterial.color.set(e.target.value));
        }

        function createSlattedSurface(width, depth, slatCount, slatThickness) {
            const surfaceGroup = new THREE.Group();
            const slatWidth = width / slatCount;
            const gap = slatWidth * 0.1;
            const effectiveSlatWidth = slatWidth - gap;
            const slatGeom = new THREE.BoxGeometry(effectiveSlatWidth, slatThickness, depth);
            for(let i = 0; i < slatCount; i++) {
                const slat = new THREE.Mesh(slatGeom, woodMaterial);
                slat.position.x = i * slatWidth - width / 2 + slatWidth / 2;
                surfaceGroup.add(slat);
            }
            return surfaceGroup;
        }

        function createTableXLegs(height, width, depth, tubeRadius) {
            const legGroup = new THREE.Group();
            const legGeom = new THREE.CylinderGeometry(tubeRadius, tubeRadius, Math.sqrt(height*height + width*width), 16);
            
            const leg1 = new THREE.Mesh(legGeom, frameMaterial);
            const leg2 = new THREE.Mesh(legGeom, frameMaterial);
            
            const angle = Math.atan2(height, width);
            
            leg1.rotation.z = -angle;
            leg2.rotation.z = angle;
            
            leg1.position.y = height / 2;
            leg2.position.y = height / 2;
            
            const frontLegs = new THREE.Group();
            frontLegs.add(leg1, leg2);
            frontLegs.position.z = -depth/2;

            const backLegs = frontLegs.clone();
            backLegs.position.z = depth/2;

            legGroup.add(frontLegs, backLegs);
            return legGroup;
        }

        function createChair() {
            const chairGroup = new THREE.Group();
            const seatWidth = 0.8;
            const seatDepth = 0.7;
            const seatHeight = 1.0;
            const backrestHeight = 1.0;
            const frameBarThickness = 0.05;
            const slatThickness = 0.04;
            const legSpread = 0.3;

            // --- Create the two main folding frames ---
            
            // Back Frame (taller, holds backrest)
            const backFrame = new THREE.Group();
            const backLegHeight = seatHeight + backrestHeight;
            const backLegGeom = new THREE.BoxGeometry(frameBarThickness, backLegHeight, frameBarThickness);
            
            const backLeg1 = new THREE.Mesh(backLegGeom, frameMaterial);
            backLeg1.position.set(-seatWidth / 2, backLegHeight / 2, 0);
            const backLeg2 = backLeg1.clone();
            backLeg2.position.set(seatWidth / 2, backLegHeight / 2, 0);

            // Crossbars for back frame
            const backCrossbarGeom = new THREE.BoxGeometry(seatWidth, frameBarThickness, frameBarThickness);
            const topCrossbar = new THREE.Mesh(backCrossbarGeom, frameMaterial);
            topCrossbar.position.y = backLegHeight - frameBarThickness;
            const midCrossbar = new THREE.Mesh(backCrossbarGeom, frameMaterial);
            midCrossbar.position.y = seatHeight + frameBarThickness;
            
            backFrame.add(backLeg1, backLeg2, topCrossbar, midCrossbar);
            backFrame.rotation.x = THREE.MathUtils.degToRad(10); // Lean it back
            backFrame.position.z = legSpread / 2;

            // Front Frame (shorter, holds seat)
            const frontFrame = new THREE.Group();
            const frontLegHeight = seatHeight;
            const frontLegGeom = new THREE.BoxGeometry(frameBarThickness, frontLegHeight, frameBarThickness);

            const frontLeg1 = new THREE.Mesh(frontLegGeom, frameMaterial);
            frontLeg1.position.set(-seatWidth / 2, frontLegHeight / 2, 0);
            const frontLeg2 = frontLeg1.clone();
            frontLeg2.position.set(seatWidth / 2, frontLegHeight / 2, 0);
            
            const seatCrossbar = new THREE.Mesh(backCrossbarGeom, frameMaterial);
            seatCrossbar.position.y = frontLegHeight - frameBarThickness;

            frontFrame.add(frontLeg1, frontLeg2, seatCrossbar);
            frontFrame.rotation.x = THREE.MathUtils.degToRad(-10); // Lean it forward
            frontFrame.position.z = -legSpread / 2;

            chairGroup.add(backFrame, frontFrame);

            // --- Slats ---
            // Seat Slats (attached to front frame)
            const seatSlats = createSlattedSurface(seatWidth, seatDepth, 8, slatThickness);
            seatSlats.position.y = seatHeight;
            seatSlats.rotation.x = THREE.MathUtils.degToRad(-10);
            seatSlats.position.z = -legSpread / 2;
            chairGroup.add(seatSlats);

            // Backrest Slats (attached to back frame)
            const backrestSlats = createSlattedSurface(seatWidth, backrestHeight, 8, slatThickness);
            backrestSlats.rotation.x = Math.PI / 2 + THREE.MathUtils.degToRad(10);
            backrestSlats.position.y = seatHeight + backrestHeight / 2;
            backrestSlats.position.z = legSpread / 2 + frameBarThickness/2;
            chairGroup.add(backrestSlats);

            return chairGroup;
        }


        function createTable() {
            const tableGroup = new THREE.Group();
            const tableSize = 1.2;
            const tableHeight = 1.4;
            const slatThickness = 0.05;
            const frameRadius = 0.04;

            // Top
            const top = createSlattedSurface(tableSize, tableSize, 10, slatThickness);
            top.position.y = tableHeight;
            tableGroup.add(top);

            // Legs
            const legs = createTableXLegs(tableHeight, tableSize * 0.8, tableSize * 0.6, frameRadius);
            tableGroup.add(legs);
            return tableGroup;
        }

        function createBistroSet() {
            const setGroup = new THREE.Group();
            const table = createTable();
            const chair1 = createChair();
            const chair2 = createChair();

            chair1.position.x = -1.5;
            chair1.rotation.y = Math.PI / 8;

            chair2.position.x = 1.5;
            chair2.rotation.y = -Math.PI / 8;

            setGroup.add(table, chair1, chair2);
            setGroup.position.y = -0.7; // Center vertically
            setGroup.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
            return setGroup;
        }


        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Main Execution ---
        window.addEventListener('load', () => {
            init();
            
            productGroup = createBistroSet();
            scene.add(productGroup);

            // Auto-center and zoom camera
            const box = new THREE.Box3().setFromObject(productGroup);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.8; 

            camera.position.set(center.x, center.y + size.y * 0.3, center.z + cameraZ);
            controls.target.copy(center);
            controls.update();

            animate();
        });
    </script>

</body>
</html>

